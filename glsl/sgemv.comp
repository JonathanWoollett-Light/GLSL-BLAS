#version 450
#extension GL_KHR_shader_subgroup_arithmetic : enable

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in; // 32^2 = 1024

layout(binding = 0) buffer Buffer1 {
    float x[];
};
layout(binding = 1) buffer Buffer2 {
    float y[];
};

layout(r32f,binding = 2) uniform image2D A;
// layout(r32f,binding = 3) uniform image2D outputs;

layout(binding = 3) buffer BufferOutputs {
    float outputs[];
};

// Need shared memory with an element for each invocation
layout(r32f,binding = 4) uniform image2D internal_holder;

layout(push_constant) uniform PushConsts {
    float alpha;
    float beta;
};

void main() {

    ivec2 size = ivec2(imageSize(A));

    float val_A = imageLoad(A,ivec2(gl_GlobalInvocationID.x,gl_GlobalInvocationID.y)).x;
    
    // Multiplier in scalars
    float new_A = val_A * x[gl_GlobalInvocationID.x];

    imageStore(internal_holder,ivec2(gl_GlobalInvocationID.x,gl_GlobalInvocationID.y),vec4(new_A));

    //barrier();
    //outputs[gl_GlobalInvocationID.x] = 5;

    if (gl_GlobalInvocationID.x == 0) {
        float sum = 0;
        for(int i=0; i<size.x; i++) {
            sum += imageLoad(internal_holder,ivec2(i,gl_GlobalInvocationID.y)).x;
        }
        //barrier();
        float new_y = y[gl_GlobalInvocationID.y] * beta;

        //outputs[gl_GlobalInvocationID.y] = beta;
        //outputs[gl_GlobalInvocationID.y] = imageLoad(internal_holder,ivec2(gl_GlobalInvocationID.y,956)).x;
        //outputs[gl_GlobalInvocationID.y] = alpha;
        //outputs[gl_GlobalInvocationID.y] = new_y;
        //outputs[gl_GlobalInvocationID.y] = gl_GlobalInvocationID.y;
        //outputs[gl_GlobalInvocationID.y] = imageLoad(internal_holder,ivec2(size.x-1,gl_GlobalInvocationID.y)).x;
        outputs[gl_GlobalInvocationID.y] = sum * alpha + new_y;
    }
}