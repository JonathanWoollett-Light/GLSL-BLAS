#version 450
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_EXT_shader_atomic_float: enable

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) buffer Buffer0 {
    float x[];
};
layout(binding = 1) buffer Output {
    uint indx_max; //Global maximum index
};

const float neg_inf = -1. / 0.; // practically float::min()
float g_max = neg_inf; // Global maximum value

const int sumSubGroupSize = 64; // = workgroup size / subgroup size = 1024 / 64
shared float sdata[sumSubGroupSize]; // subgroup max values



void main() {
    uint indx = gl_GlobalInvocationID.x;
    float val = abs(x[indx]); // Temp max: invocation absolute value -> subgroup max -> workgroup max

    // For the invocation with the max subgroup value...
    if (val == subgroupMax(val)) {
        sdata[gl_SubgroupID] = val;
    }

    // Wait for all invocations to have maxed and stored
    barrier();

    // For 1 subgroup in the workgroup
    if (gl_SubgroupID == 0)
    {
        // Given we have S subgroups and I invocations to work with (where I>=S), we only need to set S of I invocations to the subgroup maxes.
        // (`neg_inf` used to prevent max selecting the respective invocations)
        float s_max = gl_SubgroupInvocationID < gl_NumSubgroups ? sdata[gl_SubgroupInvocationID] : neg_inf;
        
        // For the subgroup with the max workgroup value...
        if (s_max == subgroupMax(s_max)) {
             // If `g_max=Max(g_max,s_max)`
            atomicExchange(g_max, max(g_max,s_max)); 
            // atomicCompSwap(g_max, min(g_max,s_max), s_max);
        }
    }
    // Wait for all workgroups to check/set `g_max`
    barrier();
    // If the value of this invocation is the maximum global value set the global maximum index to the index of this invocation
    if (val == g_max) indx_max = indx;
}