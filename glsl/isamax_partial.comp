#version 450
#extension GL_KHR_shader_subgroup_arithmetic: enable

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) buffer Buffer0 {
    float x[];
};
layout(binding = 1) buffer Output {
    uint indx_max[]; // Workgroup maximum indicies
};

const float neg_inf = -1. / 0.; // practically float::min()

const int sumSubGroupSize = 64; // = workgroup size / subgroup size = 1024 / 64
shared float sdata[sumSubGroupSize]; // subgroup max values

//shared float w_max; // Workgroup max value

void main() {
    uint indx = gl_GlobalInvocationID.x;
    float val = abs(x[indx]); // Temp max: invocation absolute value -> subgroup max -> workgroup max

    // For the invocation with the max subgroup value:
    // TODO How does this perform vs `sdata[gl_SubgroupID]=subgroupMax(val);` ?
    if (val == subgroupMax(val)) {
        sdata[gl_SubgroupID] = val;
    }

    // Wait for all invocations to have maxed and stored
    barrier();

    // For 1 subgroup in the workgroup
    if (gl_SubgroupID == 0)
    {
        // Given we have S subgroups and I invocations to work with (where I>=S), we only need to set S of I invocations to the subgroup maxes.
        // (`neg_inf` used to prevent max selecting unused shared elements)
        float s_max = gl_SubgroupInvocationID < gl_NumSubgroups ? sdata[gl_SubgroupInvocationID] : neg_inf;
        
        // For the invocation in the subgroup representing the max subgroup value within the workgroup:
        if (s_max == subgroupMax(s_max)) indx_max[gl_WorkGroupID] = s_max;
    }
}