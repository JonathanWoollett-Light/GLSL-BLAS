#version 450

// sasum operation:
// - subgroup operations
// - atomics
// + inter-workgroup buffer

// I beleive this is worst (slowest) version of sasum.
// (although its lack of both subgroup operations adn atomics make it more likely to be supported)

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) buffer Inputs {
    float x[];
};

// For doing summation this way, we require inter-workgroup memory
layout(binding = 1) buffer Internal {
    float reduceSums[]; // len(reduceSums) = n/2
};

// Our final total sum
layout(binding = 2) buffer Output {
    float sum;
};

// Length of `x`
layout(push_constant) uniform PushConsts {
    uint n; // n=len(x)
};

void main() {
    const uint indx = gl_GlobalInvocationID.x;

    // Applies abs to all inputs
    x[indx] = abs(x[indx]);
    
    uint space = n/2;

    barrier();
    
    // This is effectively the first iteration
    if (indx < space) {
        reduceSums[indx] = x[2*indx] + x[2*indx+1];
    }

    const uint logLen = uint(log2(n));

    // The logic here is fairly tricky.
    // I read a paper and some explanation by some nvidia guy when I learned it, I can't find these anymore,
    //  but I made a diagram of an example, pls see 'sasum.png'
    for(uint d=2; d<=logLen; d++) {
        space = n/(2^d);
        barrier(); // Waits till every invocation has finished this layer to begin next
        if (indx < space) {
            reduceSums[indx] = reduceSums[2*indx] + reduceSums[2*indx+1];
        }
    }

    barrier();

    // For 1 invocation in the workgroup, set the workgroup sum as the total sum
    if(gl_LocalInvocationID.x == 0) sum = reduceSums[0];
}
